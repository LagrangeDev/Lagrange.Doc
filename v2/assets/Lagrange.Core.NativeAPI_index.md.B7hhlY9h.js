import{_ as a,c as e,o as r,aj as t}from"./chunks/framework.DJyex2_T.js";const _=JSON.parse('{"title":"Lagrange.Core.NativeAPI","description":"","frontmatter":{},"headers":[],"relativePath":"Lagrange.Core.NativeAPI/index.md","filePath":"Lagrange.Core.NativeAPI/index.md","lastUpdated":1749013307000}'),i={name:"Lagrange.Core.NativeAPI/index.md"},o=t('<h1 id="lagrange-core-nativeapi" tabindex="-1">Lagrange.Core.NativeAPI <a class="header-anchor" href="#lagrange-core-nativeapi" aria-label="Permalink to &quot;Lagrange.Core.NativeAPI&quot;">​</a></h1><h2 id="简介" tabindex="-1">简介 <a class="header-anchor" href="#简介" aria-label="Permalink to &quot;简介&quot;">​</a></h2><p>Lagrange.Core.NativeAPI(以下简称NAPI)是对Lagrange.Core使用<a href="https://zh.m.wikipedia.org/wiki/%E5%BA%94%E7%94%A8%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%8E%A5%E5%8F%A3" target="_blank" rel="noreferrer">C ABI</a>封装的本机库,采用NativeAOT,无需运行时,旨在为各应用端提供封装的嵌入的协议端使用方法</p><h2 id="协议许可" tabindex="-1">协议许可 <a class="header-anchor" href="#协议许可" aria-label="Permalink to &quot;协议许可&quot;">​</a></h2><p>Lagrange.Core基于GPl3.0开源,所以在你使用它的衍生物二进制NativeAPI做动态链接调用的时候,不需要把你自己的代码开源,但你仍然需要在一个合适的位置声明协议的提供方,并附带原项目的链接</p><h2 id="约定" tabindex="-1">约定 <a class="header-anchor" href="#约定" aria-label="Permalink to &quot;约定&quot;">​</a></h2><p>NativeAPI的命名采取驼峰命名的方式,我们尽可能的保证与Core的类型命名一致,但对于实在没无办法避开的OOP/GC类型,文档里会进行额外的说明</p><p><strong>所有</strong>由NativeAPI发送的指针均需要通过NativeAPI的FreeMemory()方法进行释放,同时,所有传给NativeAPI的指针在方法调用结束后都需要由调用方释放,NativeAPI内部不会在方法结束调用后仍然持有传入的指针和内存</p><p>所有的string都会被转化为以utf8编码的NativeByteArray类型封送,不会存在其他格式的字符串,NAPI也仅接受对应的格式传入</p><p>NativeAPI不使用SAFEARRAY,所有的数组都有对应的封装,并声明其长度,相关封装定义可以在文档的Common类下查看</p><h2 id="开始开发" tabindex="-1">开始开发 <a class="header-anchor" href="#开始开发" aria-label="Permalink to &quot;开始开发&quot;">​</a></h2><p>1.基本类型</p><p>2.登录</p><p>3.事件</p><p>4.发送消息</p>',15),n=[o];function p(s,d,l,h,c,A){return r(),e("div",null,n)}const P=a(i,[["render",p]]);export{_ as __pageData,P as default};
